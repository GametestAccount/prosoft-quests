# The Descent

https://www.codingame.com/training/easy/the-descent

**Задание**:
Уничтожить горы до того, как космический корабль столкнется с одной из них. Для этого необходимо стрелять в самую высокую гору на своем пути.

**Входные данные**:
- в каждой итерации даётся массив высот гор mountainH (0 ≤ mountainH ≤ 9)

**Выходные данные**:
- индекс горы, которую нужно поразить в текущей итерации

**Решение**:
Будем сохранять максимальную высоту горы (max_mountain_h) и её индекс (max_mountain_index). При считывании высоты i-й горы, сравниваем полученное значение с максимальным значением высоты (по умолчанию в max_mountain_h самое минимальное значение, т.е. 0), если i-е значение высоты больше max_mountain_h , то оно становится новым максимальным значением, также сохраняем индекс этого значения, иначе - идём на следующую итерацию. 

---
# Temperatures

https://www.codingame.com/training/easy/temperatures

**Задание**:
Проанализировать записи о температуре и найти близкое к нулю значение. Если два числа на одном и том же расстоянии к нулю, то более близким является положительное число.

**Входные данные**:
- N - кол-во значений (0 ≤ N < 10000)
- Значения температуры (в диапазоне от -273 до 5526)

**Выходные данные**:
- 0 - если данные о температуре не введены, в противном случае вывести значение температуры, которое ближе всего к нулю

**Решение**:
В переменной min_temp будем сохранять значение температуры с минимальным расстоянием до нуля, по умолчанию установим значение, равное максимально возможной температуре (5526 в данной задаче). Если модуль введённого значения температуры меньше модуля переменной min_temp, то сохраняем введённое значение, ибо оно ближе к нулю. Для разрешения конфликта и придания приоритета положительному значению, добавим дополнительное условие: если введённое значение по модулю равно модулю min_temp и введённое значение положительное (то есть больше нуля), то сохраним его, как значение, более близкое к нулю.

```C
int t;
scanf("%d", &t);

if (abs(t) < abs(min_temp))
	min_temp = t;

if (abs(t) == abs(min_temp))
	if (t > 0)
		min_temp = t;
```

---
# Horse-racing Duals

https://www.codingame.com/ide/puzzle/horse-racing-duals

**Задание**:
Написать программу, которая по заданному списку сил лошадей находит минимальную разницу между двумя самыми близкими по силе лошадьми.

**Входные данные**:
- первая строка: количество лошадей N (1 < N < 100000)
- следующие N строк: сила каждой лошади Pi (0 ≤ Pi ≤ 10000000)

**Выходные данные**:
- минимальная разница между двумя самыми близкими по силе лошадьми

**Решение**:
Решение основано на идее, что минимальная разница между любыми двумя числами в массиве обязательно достигается между двумя соседними элементами в отсортированном порядке. Поэтому сначала считываем силы всех лошадей в массив, сортируем его с помощью стандартной функции qsort, а затем одним проходом по массиву вычисляем разности между соседними элементами, отслеживая минимальную из них. Такой подход обеспечивает оптимальную временную сложность за счёт сортировки и линейного прохода, избегая неэффективного перебора всех пар.

```C
qsort(P, N, sizeof(int), compare);

int min_diff = MAX_DIFF;

for (int i = 1; i < N; i++)
{
    int diff = P[i] - P[i - 1];

    if (diff < min_diff)
        min_diff = diff;
}
```

---
# Defibrillators

https://www.codingame.com/ide/puzzle/defibrillators

**Задание**:
Программа должна найти ближайший к пользователю дефибриллятор по его координатам, используя предоставленные данные о всех устройствах.

**Входные данные**:
- первая строка: долгота пользователя (в градусах)
- вторая строка: широта пользователя (в градусах)
- третья строка: количество дефибрилляторов (0 < N < 10000)
- следующие N строк: описание каждого дефибриллятора в формате ID;Name;Address;Phone;Longitude;Latitude, где координаты заданы в градусах, а десятичным разделителем является запятая

**Выходные данные**:
- название самого близкого дефибриллятора к позиции пользователя

**Решение**:
Считываем координаты пользователя и список дефибрилляторов, парсим каждую строку, заменяя запятые на точки в числовых полях для корректного преобразования в double, затем вычисляем расстояние от пользователя до каждого дефибриллятора по заданной формуле, после чего находим минимальное расстояние и выводим имя соответствующего дефибриллятора. В программе учтены ограничения на размер входных данных (чтобы не вызвать переполнение буфера).

---
# 1D Spreadsheet

https://www.codingame.com/ide/puzzle/1d-spreadsheet

**Задание**:
Дан одномерный лист из N ячеек. Каждая ячейка содержит:
- операцию (VALUE, ADD, SUB, MULT);
- два аргумента (могут быть либо числом, либо ссылкой на другую ячейку)
Требуется вычислить значение каждой ячейки, учитывая, что ссылки могут указывать на ячейки, ещё не вычисленные.

**Входные данные**:
- первая строка: количество ячеек (1 ≤ N ≤ 100)
- далее N строк: операция и два аргумента

**Выходные данные**:
- N строк: значение каждой ячейки

**Решение**:
Считываем все команды и сохраняем их в массиве структур, инициализируем массив значений ячеек как INT_MAX (признак "не вычислено"). Проходим по всем командам, пытаясь выполнить каждую, при успешном выполнении помечаем команду как выполненную и увеличиваем счётчик выполненных команд, при этом динамически обновляем нижнюю границу для оптимизации. Алгоритм гарантирует завершение, т.к. циклические ссылки исключены, а каждая команда рано или поздно станет выполнимой, когда все её зависимости будут вычислены.
